#!/usr/bin/env bash
# ----------------------------------------------------------------------------------
# Filename:     nas_installnfs.sh
# Description:  Source script for installing & setup of NFS
# ----------------------------------------------------------------------------------

#---- Source -----------------------------------------------------------------------
#---- Dependencies -----------------------------------------------------------------

# Requires 'pve_node_LIST' array generated by script 'nas_identify_pvehosts.sh'

# Check for NFS installation
if [ ! $(dpkg -s nfs-kernel-server > /dev/null 2>&1; echo $?) == 0 ]; then
  msg "Installing NFS (be patient, may take a while)..."
  apt-get install -y nfs-kernel-server >/dev/null
fi

#---- Static Variables -------------------------------------------------------------

# No. of reserved PVE node IPs
PVE_HOST_NODE_CNT='5'

# NFS string and settings
NFS_STRING='(rw,async,no_wdelay,no_root_squash,insecure_locks,sec=sys,anonuid=1025,anongid=100)'
NFS_EXPORTS='/etc/exports'

#---- Other Variables --------------------------------------------------------------
#---- Other Files ------------------------------------------------------------------
#---- Body -------------------------------------------------------------------------

#---- Install and Configure NFS
section "Configuring NFS Server"

# Check if Static hostnames are mapped
if [ ! $(nslookup ${PVE_HOSTNAME} >/dev/null 2>&1; echo $?) == '0' ]; then
  # Set NFS export method (because nslookup failed to resolve PVE primary hostname)
  display_msg1="DNS Server 1:$(ip route show default | awk '/default/ {print $3}' | awk -F'.' 'BEGIN {OFS=FS} { print $1, $2, $3, "254" }'):Set your PiHole IP address
  DNS Server 2:$(ip route show default | awk '/default/ {print $3}'):Set your router DNS IP"
  display_msg2="/srv/$(hostname)/audio:${PVE_HOST_IP}(rw,sync):IP address example
  /srv/$(hostname)/audio:${PVE_HOSTNAME}(rw,sync):Hostname example"
  msg_box "#### PLEASE READ CAREFULLY - ADDITIONAL NFS SHARED FOLDERS ####\n\nWe use NFS to create PVE shared storage mount points. All PVE hosts are configured with static IP addresses. Some network DNS servers may not map arbitrary hostnames to their static IP addresses ( UniFi for example ). We recommend the User configures NFS exports to use IP addresses instead of hostnames when configuring NFS '/etc/exports'.\nBut you have the option to use hostnames if you want to. A solution is use a PiHole DNS server to resolve all static IP addresses. Add each PVE host IP address to the PiHole local DNS record and set the PiHole DNS settings section to use 'Use Conditional Forwarding' with the correct required parameters.\n\n$(printf '%s\n' "${pve_node_LIST[@]}" | awk -F',' -v searchdomain="$(hostname -d)" 'BEGIN {OFS=FS} { print $1"."searchdomain, $2 }' | column -s "," -t -N "DOMAIN,IP ADDRESS" | indent2)\n\nThen edit each PVE host DNS setting exactly ( in identical order, PiHole first ) as follows:\n\n$(printf '%s\n' "${display_msg1}" | column -s ":" -t -N "PVE HOST DNS SETTING,IP ADDRESS,DESCRIPTION" | indent2)\n\nIn the event the User changes their PVE hosts IP addresses you must update the PiHole local DNS record. AN example of the two types of NFS exports is as follows:\n\n$(printf '%s\n' "${display_msg2}" | column -s ":" -t -N "EXPORT SHARE,NFS OPTIONS,TYPE" | indent2)"

  unset OPTIONS_VALUES_INPUT
  unset OPTIONS_LABELS_INPUT
  OPTIONS_VALUES_INPUT+=( "OPTION_01" "OPTION_02" )
  OPTIONS_LABELS_INPUT+=( "NFS by Hostnames - NFS exports by hostnames" \
  "NFS by Static IP - NFS exports by IP address." )
  makeselect_input2
  singleselect SELECTED "$OPTIONS_STRING"
  if [ ${RESULTS} == 'OPTION_01' ]; then
    NFS_EXPORT_TYPE='0'
  elif [ ${RESULTS} == 'OPTION_02' ]; then
    NFS_EXPORT_TYPE='1'
  fi
else
  # NFS exports set to use hostnames
  NFS_EXPORT_TYPE='0'
fi

# Create array
rm_match='^\#.*$|^\s*$|^git.*$|^homes.*$|^openvpn.*$|^sshkey.*$'
# 'nas_basefolder_extra_LIST' array
unset nas_basefolder_extra_LIST
nas_basefolder_extra_LIST=()
while IFS= read -r line; do
  [[ "$line" =~ (${rm_match}) ]] && continue
  nas_basefolder_extra_LIST+=( "$line" )
done < nas_basefolderlist_extra

# 'nas_basefolder_LIST' array
unset nas_basefolder_LIST
nas_basefolder_LIST=()
while IFS= read -r line; do
  [[ "$line" =~ (${rm_match}) ]] || [[ ${nas_basefolder_extra_LIST[@]} =~ "$line" ]] && continue
  nas_basefolder_LIST+=( "$line" )
done < nas_basefolderlist

# Query additional shares for inclusion
if [[ ${#nas_basefolder_extra_LIST[@]} -ge '1' ]]; then
  echo
  msg_box "#### PLEASE READ CAREFULLY - ADDITIONAL NFS SHARED FOLDERS ####\n\nIn a previous step you created additional custom shared folders. You can now choose which additional folders are to be included as NFS shares."
  echo
  while true; do
    OPTIONS_VALUES_INPUT=$(printf '%s\n' "${nas_basefolder_extra_LIST[@]}" | sed -e '$anone,none')
    OPTIONS_LABELS_INPUT=$(printf '%s\n' "${nas_basefolder_extra_LIST[@]}" | awk -F',' -v var="${DIR_SCHEMA}" '{print var"/"$1, "| Folder Label: "$2}' | sed -e '$aNone | Exclude all my additional shares from NFS')
    makeselect_input1 "$OPTIONS_VALUES_INPUT" "$OPTIONS_LABELS_INPUT"
    multiselect SELECTED "$OPTIONS_STRING"
    if [[ ${RESULTS[@]} =~ '^none,none$' ]]; then
      info "All custom share folders are excluded from NFS exports."
      echo
      break
    elif [[ ! ${RESULTS[@]} =~ '^none,none$' ]] && [ ! ${#RESULTS[@]} == '0' ]; then
      nas_basefolder_LIST+=( "$(printf '%s\n' "${RESULTS[@]}")" )
      echo
      break
    fi
  done
fi

# # Update NFS exports file
# msg "Creating new NFS exports..."
# while IFS=',' read -r dir desc group permission user_groups; do
#   [[ ${dir} =~ 'none' ]] && continue
#   # Check for dir
#   if [ -d "${DIR_SCHEMA}/$dir" ]; then
#     if [[ $(grep -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS}) ]]; then
#       # Edit existing nfs export share
#       i=$(echo ${PVE_01_IP} | cut -d . -f 4)
#       counter=0
#       until [ $counter == ${PVE_HOST_NODE_CNT} ]
#       do
#         PVE_0X_IP="$(echo ${PVE_01_IP} | cut -d"." -f1-3).${i}"
#         match=$(grep --color=never -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS})
#         if [[ $(echo "${match}" | grep -ws "${PVE_0X_IP}") ]]; then
#           substitute=$(echo "${match}" | sed -e "s/${PVE_0X_IP}[^\t]*/${PVE_0X_IP}${NFS_STRING}/")
#           sed -i "s|${match}|${substitute}|" ${NFS_EXPORTS}
#         else
#           # Add to existing nfs export share
#           substitute=$(echo "${match}" | sed -e "s/$/\t${PVE_0X_IP}${NFS_STRING}/")
#           sed -i "s|${match}|${substitute}|g" ${NFS_EXPORTS}
#         fi
#         (( i=i+1 ))
#         counter=$(( counter+1 ))
#       done
#       info "Updating NFS share: ${YELLOW}${DIR_SCHEMA}/${dir}${NC}"
#     else
#       # Create new nfs export share
#       printf "\n"${DIR_SCHEMA}/${dir}"" >> ${NFS_EXPORTS}
#       i=$(echo ${PVE_01_IP} | cut -d . -f 4)
#       counter=0
#       until [ $counter == ${PVE_HOST_NODE_CNT} ]
#       do
#         PVE_0X_IP="$(echo ${PVE_01_IP} | cut -d"." -f1-3).${i}"
#         match=$(grep --color=never -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS})
#         # Add to existing nfs export share
#         substitute=$(echo "${match}" | sed -e "s/$/\t${PVE_0X_IP}${NFS_STRING}/")
#         sed -i "s|${match}|${substitute}|g" ${NFS_EXPORTS}
#         (( i=i+1 ))
#         counter=$(( counter+1 ))
#       done
#       info "New NFS share: ${YELLOW}${DIR_SCHEMA}/${dir}${NC}"
#     fi
#   else
#     info "${DIR_SCHEMA}/${dir} does not exist. Skipping..."
#   fi
# done <<< $(printf '%s\n' "${nas_basefolder_LIST[@]}")
# echo



# Update NFS exports file
msg "Creating new NFS exports..."
while IFS=',' read -r dir desc group permission user_groups; do
  [[ ${dir} =~ 'none' ]] && continue
  # Check for dir
  if [ -d "${DIR_SCHEMA}/$dir" ]; then
    if [[ $(grep -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS}) ]]; then
      # Edit existing nfs export share
      while IFS=, read hostid ipaddr desc; do
        nfs_var=$(if [ ${NFS_EXPORT_TYPE} == '0' ]; then echo ${hostid}; else echo ${ipaddr}; fi)
        match=$(grep --color=never -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS})
        if [[ $(echo "${match}" | grep -ws "${nfs_var}") ]]; then
          substitute=$(echo "${match}" | sed -e "s/${nfs_var}[^\t]*/${nfs_var}${NFS_STRING}/")
          sed -i "s|${match}|${substitute}|" ${NFS_EXPORTS}
        else
          # Add to existing nfs export share
          substitute=$(echo "${match}" | sed -e "s/$/\t${nfs_var}${NFS_STRING}/")
          sed -i "s|${match}|${substitute}|g" ${NFS_EXPORTS}
        fi
      done <<< $(printf '%s\n' "${pve_node_LIST[@]}")
      info "Updating NFS share: ${YELLOW}${DIR_SCHEMA}/${dir}${NC}"
    else
      # Create new nfs export share
      printf "\n"${DIR_SCHEMA}/${dir}"" >> ${NFS_EXPORTS}
      while IFS=, read hostid ipaddr desc; do
        nfs_var=$(if [ ${NFS_EXPORT_TYPE} == '0' ]; then echo ${hostid}; else echo ${ipaddr}; fi)
        match=$(grep --color=never -xs "^${DIR_SCHEMA}/${dir}.*" ${NFS_EXPORTS})
        # Add to existing nfs export share
        substitute=$(echo "${match}" | sed -e "s/$/\t${nfs_var}${NFS_STRING}/")
        sed -i "s|${match}|${substitute}|g" ${NFS_EXPORTS}
      done <<< $(printf '%s\n' "${pve_node_LIST[@]}")
      info "New NFS share: ${YELLOW}${DIR_SCHEMA}/${dir}${NC}"
    fi
  else
    info "${DIR_SCHEMA}/${dir} does not exist. Skipping..."
  fi
done <<< $(printf '%s\n' "${nas_basefolder_LIST[@]}")
echo

# Update '/etc/hosts' file
if [ ${NFS_EXPORT_TYPE} == '0' ]; then 
echo "# --- BEGIN PVE HOST IP ADDRESS FOR NFS ---" >> /etc/hosts
while IFS=, read hostid ipaddr desc; do
  echo "${ipaddr} ${hostid}.$(hostname -d) ${hostid}" >> /etc/hosts
done <<< $(printf '%s\n' "${pve_node_LIST[@]}")
echo "# --- END PVE HOST IP ADDRESS FOR NFS ---" >> /etc/hosts
fi


#---- Restart NFS server
msg "Restarting NFS Server..."
service nfs-kernel-server restart 2>/dev/null
if [ "$(systemctl is-active --quiet nfs-kernel-server; echo $?) -eq 0" ]; then
  info "NFS Server status: ${GREEN}active (running).${NC}"
  echo
elif [ "$(systemctl is-active --quiet nfs-kernel-server; echo $?) -eq 3" ]; then
  info "NFS Server status: ${RED}inactive (dead).${NC}. Your intervention is required."
  echo
fi

#---- Finish Line ------------------------------------------------------------------